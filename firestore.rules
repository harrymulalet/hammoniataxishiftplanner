
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isTimestamp(value) {
      return value is timestamp;
    }

    function isAdmin(userId) {
      // Ensure the user document exists before trying to access its data.
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.exists && userDoc.data.role == 'admin';
    }

    function isDriver(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.exists && userDoc.data.role == 'driver';
    }

    // User profiles
    match /users/{userId} {
      allow read: if request.auth != null &&
                    (
                      (request.auth.uid == userId) || // User can read their own profile
                      isAdmin(request.auth.uid)      // Admin can read any profile
                    );
      allow list: if request.auth != null && 
                    (
                      isAdmin(request.auth.uid) || // Admin can list all users
                      request.auth.uid == 'n6XVw2d4OhU9BJk8OzuMvkSk7nN2' // Explicit allow for specific admin UID for diagnostics
                    );

      allow create: if request.auth != null &&
                      (
                        // Case 1: User creating their own profile (e.g. future self-registration)
                        // This part needs to be carefully considered if self-registration is enabled.
                        // For now, focusing on admin creation.
                        (request.auth.uid == userId &&
                         // request.resource.data.role == (request.auth.token.firebase.sign_in_provider == 'password' ? 'driver' : 'admin') && // Default to driver for email/pass
                         request.resource.data.uid == userId &&
                         request.resource.data.email == request.auth.token.email &&
                         // isTimestamp(request.resource.data.createdAt) && // Let Firestore handle serverTimestamp()
                         // request.resource.data.createdAt == request.time && // This is problematic with serverTimestamp()
                         request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                         request.resource.data.lastName is string && request.resource.data.lastName.size() > 0
                         // employeeType is optional for self-creation unless role is driver
                        )
                        ||
                        // Case 2: Admin creating a driver profile
                        (isAdmin(request.auth.uid) &&
                         request.resource.data.role == 'driver' &&
                         request.resource.data.uid == userId &&
                         request.resource.data.email is string && request.resource.data.email.size() > 0 &&
                         request.resource.data.firstName is string && request.resource.data.firstName.size() > 0 &&
                         request.resource.data.lastName is string && request.resource.data.lastName.size() > 0 &&
                         request.resource.data.employeeType is string && request.resource.data.employeeType.size() > 0
                         // serverTimestamp() will be handled by Firestore, no direct rule check needed here for `createdAt` value itself
                        )
                      );

      allow update: if request.auth != null &&
                      (
                        // Case 1: User updating their own profile (restricted fields)
                        (request.auth.uid == userId &&
                         (!request.resource.data.containsKey('email') || request.resource.data.email == request.resource.prior.data.email) &&
                         (!request.resource.data.containsKey('role') || request.resource.data.role == request.resource.prior.data.role) &&
                         request.resource.data.uid == userId &&
                         ( // createdAt handling:
                           (!request.resource.prior.data.containsKey('createdAt') || request.resource.prior.data.createdAt == null) ||
                           (request.resource.prior.data.createdAt is timestamp && request.resource.data.createdAt == request.resource.prior.data.createdAt)
                         )
                        )
                        ||
                        // Case 2: Admin updating any profile
                        (isAdmin(request.auth.uid) &&
                         request.resource.data.uid == userId
                         // Simplified: Admin can update fields. createdAt should ideally not change once set.
                         // If overwriting a stale record, the create rule's logic for createdAt (i.e. allowing serverTimestamp) is more relevant.
                         // For a targeted update, we'd prevent changing an existing valid createdAt.
                         // For now, this simplified rule for admin update focuses on identity.
                        )
                      );

      allow delete: if isAdmin(request.auth.uid); // Only admins can delete user profiles
    }

    // Taxis
    match /taxis/{taxiId} {
      allow read: if request.auth != null && 
                    (
                      isAdmin(request.auth.uid) || 
                      (isDriver(request.auth.uid) && resource.data.isActive == true)
                    );
      allow list: if request.auth != null && (isAdmin(request.auth.uid) || isDriver(request.auth.uid)); // Drivers can list to see active ones, client filters
      allow create: if isAdmin(request.auth.uid) &&
                       request.resource.data.id == taxiId &&
                       request.resource.data.licensePlate is string && request.resource.data.licensePlate.size() > 0 &&
                       request.resource.data.isActive is bool &&
                       request.resource.data.createdBy == request.auth.uid;
      allow update: if isAdmin(request.auth.uid) &&
                       request.resource.data.id == taxiId && // if ID is changing, it's a delete + create conceptually
                       request.resource.data.licensePlate is string && request.resource.data.licensePlate.size() > 0 &&
                       request.resource.data.isActive is bool &&
                       request.resource.data.createdBy == request.resource.prior.data.createdBy; // Original creator should not change
      allow delete: if isAdmin(request.auth.uid);
    }

    // Shifts
    match /shifts/{shiftId} {
      allow read: if request.auth != null &&
                    (
                      (request.auth.uid == resource.data.driverId) || // Driver can read their own shifts
                      isAdmin(request.auth.uid)                     // Admin can read any shift
                    );
      allow list: if request.auth != null && (isAdmin(request.auth.uid) || isDriver(request.auth.uid)); // Drivers list their own, Admins list all - client query filters

      allow create: if request.auth != null &&
                      get(/databases/$(database)/documents/taxis/$(request.resource.data.taxiId)).data.isActive == true &&
                      (
                        // Case 1: Driver creating their own shift
                        (isDriver(request.auth.uid) &&
                         request.resource.data.driverId == request.auth.uid &&
                         isTimestamp(request.resource.data.startTime) &&
                         isTimestamp(request.resource.data.endTime) &&
                         request.resource.data.endTime > request.resource.data.startTime
                        )
                        ||
                        // Case 2: Admin creating a shift for any driver
                        (isAdmin(request.auth.uid) &&
                         // Admin needs to provide valid driver details
                         request.resource.data.driverId is string && request.resource.data.driverId.size() > 0 &&
                         request.resource.data.driverFirstName is string && request.resource.data.driverFirstName.size() > 0 &&
                         request.resource.data.driverLastName is string && request.resource.data.driverLastName.size() > 0 &&
                         isTimestamp(request.resource.data.startTime) &&
                         isTimestamp(request.resource.data.endTime) &&
                         request.resource.data.endTime > request.resource.data.startTime
                        )
                      );

      allow update: if request.auth != null &&
                      get(/databases/$(database)/documents/taxis/$(request.resource.data.taxiId)).data.isActive == true &&
                      (
                        (request.auth.uid == request.resource.prior.data.driverId && // Driver can only update their own shifts
                         request.resource.data.driverId == request.auth.uid // And cannot change the driverId
                        ) ||
                        isAdmin(request.auth.uid) // Admin can update any shift
                      ) &&
                      isTimestamp(request.resource.data.startTime) &&
                      isTimestamp(request.resource.data.endTime) &&
                      request.resource.data.endTime > request.resource.data.startTime;
                      // Ensure other fields are validated if necessary, e.g., not changing critical old data arbitrarily

      allow delete: if request.auth != null &&
                      (
                        request.auth.uid == resource.data.driverId || // Driver can delete their own shift
                        isAdmin(request.auth.uid)                    // Admin can delete any shift
                      );
    }
  }
}

    